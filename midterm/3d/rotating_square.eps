%!PS-Adobe-3.0 EPSF-3.0
%%BoundingBox: 0 0 500 500
% import 3d lib
(3d.eps) run


realtime srand

/size 500 def
/cycles 1000 def

% disable back-face culling (because it doesn't work correctly yet)
/enable_back_face_culling false def
% full or wireframe
/render_method (wireframe) def

size 1.25 div size 3 div translate

/gridsize 15 def
/cellsize size gridsize div def
cellsize 150 div setlinewidth

% used for GOL: one is used to display, one is used to calculate because all the cells have to be updated at the same time
/old [gridsize gridsize mul {rand 2 mod} repeat] def
/current old [exch aload pop] def
/heatmap [gridsize gridsize mul {0} repeat] def

/getneighbors {
	1 dict begin
	/i exch def
	end
	/neighbors [
		i 1 gridsize add sub i gridsize sub i 1 gridsize sub sub
		i 1 sub                             i 1 add
		i 1 gridsize add add i gridsize add i 1 gridsize sub add
	] def
	/l 0 def
	0 1 7 {
		/j exch def
		/c neighbors j get gridsize gridsize mul mod abs def
		/valid c 0 gt c gridsize gridsize mul lt and def
		valid {
			old c get 1 eq {/l l 1 add def} if
		} if
	} for
	l
} def

/live {
	1 dict begin
	/i exch def end
	/l i getneighbors def

	/x i gridsize mod cellsize mul def
	/y i gridsize idiv cellsize mul def
	l 2 ne l 3 ne and {current i 0 put} {current i 1 put heatmap i heatmap i get 1 add put} ifelse
} def

/dead {
	1 dict begin
	/i exch def	end
	
	/l i getneighbors def

	/x i gridsize mod cellsize mul def
	/y i gridsize idiv cellsize mul def
	l 3 eq {current i 1 put heatmap i heatmap i get 1 add put} {current i 0 put} ifelse
} def
/cell {
	3 dict begin
	/state exch def
	/y exch def
	/x exch def
	state 1 eq { 0 0 0 setrgbcolor [x y 0] cellsize cube } {} ifelse
	end
} def

/wipe {
	newpath
	size neg size neg moveto
	size size neg lineto
	size size lineto
	size neg size lineto
	closepath
	1 1 1 setrgbcolor
	fill
	0 0 0 setrgbcolor
} def


% custom camera offsets for this example
/cPosStart [200.001 200.001 0.5] def
/cPos cPosStart def
/cAngle [-0.05 0.001 135.001] def

/cSpeed 5 def
/circleSize 500 def

/timeTaken 0 def
0 1 cycles {
	/timeTaken realtime def
	/theta exch def
	/cPos [theta cSpeed mul cos circleSize mul cPosStart 0 get add theta cSpeed mul sin circleSize mul cPosStart 1 get add cPosStart 2 get] def
	/cAngle [cAngle 0 get cAngle 1 get theta cSpeed mul 90 sub] def
	draw_axes
	0 1 0 setrgbcolor
	[200 200 0] 100 0 icosphere
	1 0 0 setrgbcolor
	[200 200 0] 200 1 icosphere
	0 0 1 setrgbcolor
	[200 200 0] 300 2 icosphere
	%0 .6 .4 setrgbcolor [0 0 0] cellsize gridsize mul square
	%0 1 gridsize 2 exp 1 sub {
	%	/i exch def
	%	/x i gridsize mod cellsize mul def
	%	/y i gridsize idiv cellsize mul def
	%	x y current i get cell
	%} for
	%0 1 gridsize 2 exp 1 sub {
	%	/i exch def
	%	% recalculate
	%	old i get 0 eq {i dead}{i live} ifelse
	%} for
	%/old current [exch aload pop] def
	/timeTaken realtime timeTaken sub def
	timeTaken 1000 div ==
	copypage
} for

showpage
%EOF